/*
*	routes.js 
* 	Used for generating shared messages in bitmap
* 	& server / create css/bitmap sprites files for emojis
*/

var path = Npm.require('path');
var cssSprites = [];
var imgSprites = [];
var totalBytesCss = 0;
var totalBytesImg = 0;
var self = this;

Meteor.startup(function () {

	var svg2png = Meteor.npmRequire('svg2png');
	var currentPath = process.env.PWD;
	var inFile = currentPath + '/public/svg/social/socialMessage.svg';
	var logoFile = currentPath + '/.public/png/logoFile.png';
	var gm = Meteor.npmRequire('gm').subClass({ imageMagick: true });

		// UNCOMMENT THIS CODE TO REGENERATE LogoFile picture used in message sharing
		// Sometimes it appears that conversion fail, then the picture is troncated
		// // convert svg logofile to png, maybe there is something more efficient
		// if (process.env.NODE_ENV=="development"){
		// 	svg2png(inFile,logoFile, function (err) {
		// 		if (err)
		// 			console.log("Error when converting logoFile into png" + err.message);
		// 		else{
		// 			gm(logoFile).crop(280,250,0,200).write(logoFile, function (err) {
		// 					if (err) console.log("Error converting croping logoFile : "+err.message);
		// 					else console.log("LogoFile png conversion ok");
		// 			});
		// 		}	
		// 	});
		// }


		// Route to serve static files generated by share message
		Router.route('messageFile', {
			where: 'server',
			path: '/messages/:atmosId',

			action: function () {
				var fs = Meteor.npmRequire('fs');
				var parser = Meteor.npmRequire('xml2json');
				var util = Meteor.npmRequire('util');
				var stream = Meteor.npmRequire('stream');
				var content;
				var outputMessagePath = path.join(process.env.PWD,'/.public/messages/');

				// creating missing folder if really (heroku hosting deletes folder each time dyno restart/move)
				mkdirp.sync(outputMessagePath);

				// atmosId == /messages/[atmosid].png
				var atmosId = this.params.atmosId.substring(0,this.params.atmosId.length-4);        
				var atmos = Atmos.findOne({_id:atmosId});
				this.response.writeHead(200, {'Content-Type': 'image/png'});

					content = fs.readFileSync(currentPath + '/public/svg/social/socialMessage.svg',{encoding: 'utf-8'});
					var jsonMessage = JSON.parse(parser.toJson(content));

					//console.log("[debug] jsonMessage : "+ JSON.stringify(jsonMessage));
					if (jsonMessage.svg && jsonMessage.svg.g && jsonMessage.svg.g.g && jsonMessage.svg.g.g.g)
						for(var i=0;i<jsonMessage.svg.g.g.g.length;i++){
							// we have svg emoji files, this way we can inject this emoji in svg message
							
							
							if (jsonMessage.svg.g.g.g[i].id == "Icon" && atmos.typeAtmos=="emoji"){
					            // open file
					            var contentIcon = "";
					            // for old emojis
					            if (atmos.icon.indexOf(".svg")==-1)
					            	contentIcon= fs.readFileSync(currentPath+'/.public/svg/tags/'+atmos.category+'/'+atmos.icon+'.svg',{encoding: 'utf-8'});
					            else{
					            	console.log("SVG marker asked, (old old storage), it will crash for old atmos (which could not be there, except if McFly comes to see us), see commit 08/05/2015");
					            	contentIcon= fs.readFileSync(currentPath+'/public/svg/markers/'+atmos.icon,{encoding: 'utf-8'});
					            }
					            jsonMessage.svg.g.g.g[i].g = JSON.parse(parser.toJson(contentIcon)).svg.g;
					        }

					        if (jsonMessage.svg.g.g.g[i].id == "Message"){
					            // split message in 35 chars (otherwise overflow)
					            console.log("message : "+atmos.vibe);

					            var tabSpan = [];
					            if (typeof(atmos.vibe)!="undefined"){
						        	var tab = atmos.vibe.cutInRows(30,120); // 120 chars max !!
						        	for(var j=0;j<tab.length;j++)
						        		tabSpan.push({"tspan":{
						        			"x":0.22,
						        			"y":15+(20*j),
						        			"$t":tab[j]
						        		}});}
						        	jsonMessage.svg.g.g.g[i].text = tabSpan;
						        }
						    }
						    content = parser.toXml(JSON.stringify(jsonMessage));


						    fd = fs.openSync(path.join(outputMessagePath,atmosId+'.svg'), 'w');
						    fs.writeSync(fd,content);
						    fs.closeSync(fd);

	    			// prepare to convert
	    			var inFile = path.join(outputMessagePath,atmosId+'.svg');
	    			var outFile = path.join(outputMessagePath,atmosId+'.png');
	    			var self = this;

	    			if(atmos.typeAtmos == "emoji"){
	    				svg2png(inFile,outFile, function (err) {
	    					if (err)
	    						console.log("Error : "+JSON.stringify(err));
					        // stream is there and save in temp
					        var stream = fs.createReadStream(outFile);
					        return stream.pipe(self.response);
					    });
	    			}
	    			if (atmos.typeAtmos == "photo" || atmos.typeAtmos == "karmaStoreEmoji"){



	    				var photo;
	    				if (atmos.typeAtmos == "photo")
	    					photo= Photos.findOne({_id:atmos.photo}).photo;
	    				else
	    					photo = atmos.karmaStoreEmoji;

	    				var self = this;

						  //we convert photo base64 image into file
						var ext = photo.match(/([^\/^;]*);/)[0]
						var photoFile = path.join(outputMessagePath,'photo-'+atmosId+'.'+ext.substring(0,ext.length-1));
						var resultFile = path.join(outputMessagePath,'result-'+atmosId+'.png');
						console.log("Time before substringing : " + (new Date()).getTime());
						var temp = photo.substring(photo.indexOf(",")+1);
						console.log("Time before decoding : " + (new Date()).getTime());
						base64_decode_to_fs(temp,photoFile);
						console.log("Time after decoding : " + (new Date()).getTime());

					  	if (atmos.typeAtmos == "photo"){
    					    // we resize photo to have a width of 280px and we assemble with logo and convert to png
    					    svg2png(inFile,outFile, function (err) {
    					    	gm(outFile).resize(280).crop(280,300,0,140).write(outFile,function(err){
    					    		gm(photoFile).autoOrient().resize(280).append(outFile).write(resultFile, function (err) {
    					    			console.log("Time after resizing : " + (new Date()).getTime());
		    					    	// remove logoFile tempfile
		    					    	fs.unlink(outFile);
		    					    	if (err) console.log("Error resizing + append photofile + logoFile : "+err.message);
		    					    	else{
		    								// we send it to the world
		    								var stream = fs.createReadStream(resultFile);
		    								return stream.pipe(self.response);
		    							}
		    						});
    					    	});
    					    });
    					}

    					if (atmos.typeAtmos == "karmaStoreEmoji"){
    						var blankImage = path.join(process.env.PWD,'/.public/png/70x140.png');

    						svg2png(inFile,outFile, function (err) {
						    	// resize logosize
						    	console.log("Time after svg2png : " + (new Date()).getTime());
					    		gm(outFile).resize(280).crop(280,300,0,140).write(outFile,function(err){
	    					    // we resize photo to have a width of 280px and we assemble with logo and convert to png
	    					    // resize file to 140x140
		    					    console.log("Time after resizing to width 280px : " + (new Date()).getTime());
		    					    gm(photoFile).resize(140,140).write(photoFile,function(err){
		    					    	if (err) console.log("Error resizing + append photofile + logoFile : "+err.message);
		    					    		// append from left to right now ! (gm doesn't work with combining )
		    					    		gm(blankImage).append(photoFile,true).append(blankImage,true).write(photoFile,function(err){
		    					    			console.log("Time after horizontal appending : " + (new Date()).getTime());
		    					    			gm(photoFile).append(outFile,false).write(resultFile, function (err) {
		    					    				console.log("Time after resizing : " + (new Date()).getTime());
					    					    	// remove logoFile tempfile
					    					    	fs.unlink(outFile);
					    					    	fs.unlink(photoFile);
					    					    	if (err) console.log("Error resizing + append photofile + logoFile : "+err.message);
					    					    	else{
					    								// we send it to the world
					    								var stream = fs.createReadStream(resultFile);
					    								return stream.pipe(self.response);
					    							}
					    						});
		    					    		});
		    					    });
								});
							});
						}
					}
}});

		// Route to serve static files sprites css/svg generated by server @ start with in-memory system to
		// be efficient, later we will have to think about cdn to serve those files.
		Router.route('spriteFilePng', {
			where: 'server',
			path: '/png/sprites/:category/:filename',
			action: function(){
				serveSprite("png",this.params.category,this.params.filename,this);
			}
		});
		Router.route('spriteFileSvg', {
			where: 'server',
			path: '/svg/sprites/:category/:filename',
			action: function(){
				serveSprite("svg",this.params.category,this.params.filename,this);
			}
		});


		function serveSprite(imageType,category,filename,self) {
			if (filename.substring(filename.length-3)=="css"){
				if (cssSprites[imageType+"/"+category+"/"+filename]!=null){
					self.response.writeHead(200, {'Content-Type': 'text/css'});
					console.log("using in-memory css");
					self.response.write(cssSprites[imageType+"/"+category+"/"+filename]);
					self.response.end();
				}else{
					var fullpath = path.join(process.env.PWD,'/.public/'+imageType+'/sprites/',category,filename);
					if (fs.existsSync(fullpath)){
						self.response.writeHead(200, {'Content-Type': 'text/css'});
						var content = fs.readFileSync(fullpath, {encoding: 'utf-8'});
						cssSprites[imageType+"/"+category+"/"+filename] = content;
						totalBytesCss+=content.length;
						console.log("push in-memory "+ imageType+"/"+category+"/"+filename + " total : "+content.length+" bytes, total for css :"+totalBytesCss);
						self.response.write(content);
					}else{
						self.response.writeHead(404, {'Content-Type': 'text/css'});
					}
					self.response.end();	
				}
			}else{
				if (imageType=="png")
					self.response.writeHead(200, {'Content-Type': 'image/png'});
				else
					self.response.writeHead(200, {'Content-Type': 'image/svg+xml'});

				if (imgSprites[imageType+"/"+category+"/"+filename]!=null){
					console.log("using in-memory image");
					self.response.write(imgSprites[imageType+"/"+category+"/"+filename]);
					self.response.end();
				}else{
					var content;

					if (imageType=="png")
						content = fs.readFileSync(path.join(process.env.PWD,'/.public/png/sprites/',category,filename));
					else 
						content = fs.readFileSync(path.join(process.env.PWD,'/.public/svg/sprites/',category,filename), {encoding: 'utf-8'});
					imgSprites[imageType+"/"+category+"/"+filename] = content;
					totalBytesImg+=content.length;
					console.log("push in-memory "+ imageType+"/"+category+"/"+filename + " for : "+content.length+" bytes, total for img :"+totalBytesImg);
					self.response.write(content);
					self.response.end();
				}
			}
		}
	});